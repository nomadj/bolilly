// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract StudentNFT is ERC721Enumerable, Ownable, ReentrancyGuard {
    uint256 private _nextTokenId = 1;

    /// @dev token URIs
    mapping(uint256 => string) private _tokenURIs;

    /// -----------------------------
    /// STUDENT REQUEST SYSTEM
    /// -----------------------------

    /// @notice Users who have requested student approval
    mapping(address => bool) public hasRequested;

    /// @notice Users whose request was approved by the owner
    mapping(address => bool) public isApprovedStudent;

    /// @notice Users whose request was denied
    mapping(address => bool) public isDenied;

    /// @notice List of all pending requests
    address[] public pendingRequests;

    event StudentRequested(address indexed user);
    event StudentApproved(address indexed user);
    event StudentDenied(address indexed user);
    event TokenMinted(address indexed to, uint256 tokenId);
    event TokenBurned(address indexed user, uint256 tokenId);

    constructor() ERC721("StudentNFT", "SNFT") Ownable(msg.sender) {}

    // ------------------------------------------------------------
    // INTERNAL HELPERS
    // ------------------------------------------------------------

    /// @dev returns true if user already has a token
    function ownsToken(address user) public view returns (bool) {
        return balanceOf(user) > 0;
    }

    /// ------------------------------------------------------------
    /// REQUEST LOGIC
    /// ------------------------------------------------------------

    /// @notice User requests to become a student
    function requestToBecomeStudent() external {
        require(!hasRequested[msg.sender], "Already requested");
        require(!isApprovedStudent[msg.sender], "Already approved");
        require(!isDenied[msg.sender], "Request previously denied");

        hasRequested[msg.sender] = true;
        pendingRequests.push(msg.sender);

        emit StudentRequested(msg.sender);
    }

    /// @notice Owner approves a pending student request
    function approveStudent(address user) external onlyOwner {
        require(hasRequested[user], "User never requested");
        require(!isApprovedStudent[user], "Already approved");
        require(!isDenied[user], "User denied");

        isApprovedStudent[user] = true;
        hasRequested[user] = false;

        _removePending(user);

        emit StudentApproved(user);
    }

    /// @notice Owner denies a pending student request
    function denyStudent(address user) external onlyOwner {
        require(hasRequested[user], "User never requested");

        isDenied[user] = true;
        hasRequested[user] = false;

        _removePending(user);

        emit StudentDenied(user);
    }

    /// @dev remove user from pendingRequests efficiently
    function _removePending(address user) internal {
        uint256 len = pendingRequests.length;
        for (uint256 i = 0; i < len; i++) {
            if (pendingRequests[i] == user) {
                pendingRequests[i] = pendingRequests[len - 1];
                pendingRequests.pop();
                return;
            }
        }
    }

    /// ------------------------------------------------------------
    /// MINTING / BURNING
    /// ------------------------------------------------------------

    /// @notice Approved users may mint exactly ONE NFT
    function mint(string memory uri) external nonReentrant {
        require(isApprovedStudent[msg.sender], "Not approved");
        require(!ownsToken(msg.sender), "Already owns token");

        uint256 tokenId = _nextTokenId++;
        _safeMint(msg.sender, tokenId);
        _tokenURIs[tokenId] = uri;

        emit TokenMinted(msg.sender, tokenId);
    }

    function burn(uint256 tokenId) external nonReentrant {
        require(ownerOf(tokenId) == msg.sender, "Not token owner");

        _burn(tokenId);
        delete _tokenURIs[tokenId];

        emit TokenBurned(msg.sender, tokenId);
    }

    /// ------------------------------------------------------------
    /// TOKEN URI
    /// ------------------------------------------------------------

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "URI query for nonexistent token");
        return _tokenURIs[tokenId];
    }

    /// ------------------------------------------------------------
    /// VIEW HELPERS
    /// ------------------------------------------------------------

    function getPendingRequests() external view returns (address[] memory) {
        return pendingRequests;
    }
}
